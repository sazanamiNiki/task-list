# Task Workflow Skill

実行計画に基づいてタスクを自動的に管理するスキルです。

## スキルの発動条件

このスキルは以下の状況で自動的に有効化されます：

1. **EnterPlanMode を使用する時**: 実行計画を作成する前
2. **ExitPlanMode を使用する時**: 実行計画を完了した後
3. **実装作業の各ステップを完了した時**: コード生成、ファイル編集、ビルドなど

## セッション名の取得

タスクのセッション名は、カレントディレクトリ名から自動的に取得します：

```typescript
// セッション名の取得例
const currentDir = process.cwd();
const sessionId = currentDir.split('/').pop() || 'default';
```

実際には、以下のようにbashコマンドで取得します：

```bash
basename $(pwd)
```

## タスク管理のワークフロー

### 1. 実行計画作成時（ExitPlanMode 直前）

実行計画を完成させたら、**ExitPlanMode を呼び出す前に**、計画の各ステップをタスクとして追加します。

**手順:**

1. セッション名を取得
2. 実行計画から各ステップのタイトルを抽出
3. `add_tasks` MCPツールを呼び出してタスクを作成
4. 作成されたタスクのIDを記録（後で更新するため）

**例:**

実行計画:
```
Phase 1: 認証システムの実装
1. ユーザースキーマの作成
2. ログインAPIの実装
3. トークン検証ミドルウェアの追加

Phase 2: テストとドキュメント
4. ユニットテストの追加
5. APIドキュメントの更新
```

MCPツール呼び出し:
```json
{
  "name": "add_tasks",
  "arguments": {
    "sessionId": "my-project",
    "titles": [
      "ユーザースキーマの作成",
      "ログインAPIの実装",
      "トークン検証ミドルウェアの追加",
      "ユニットテストの追加",
      "APIドキュメントの更新"
    ]
  }
}
```

### 2. 各ステップ開始時

ステップの実装を開始する際、該当タスクのステータスを `in_progress` に更新します。

**MCPツール呼び出し:**
```json
{
  "name": "update_task",
  "arguments": {
    "sessionId": "my-project",
    "id": 1,
    "status": "in_progress"
  }
}
```

### 3. 各ステップ完了時

ステップが完了したら、以下のルールに従ってステータスを更新します：

#### ステータス: `done`

以下の場合は `done` に設定：
- ファイルの作成・編集が完了した
- コードの生成が完了した
- 設定ファイルの更新が完了した
- 依存関係のインストールが完了した
- 自動化された操作が成功した
- **ユーザーが次のステップに自動で進むことを許容している**

**MCPツール呼び出し:**
```json
{
  "name": "update_task",
  "arguments": {
    "sessionId": "my-project",
    "id": 1,
    "status": "done"
  }
}
```

#### ステータス: `check`

以下の場合は `check` に設定：
- ビルドやテストを実行した（結果の確認が必要）
- 重要な設定変更を行った（レビューが必要）
- 外部サービスへのデプロイを行った（確認が必要）
- **ユーザーの確認や承認を仰ぐ必要がある**
- エラーや警告が発生した

**MCPツール呼び出し:**
```json
{
  "name": "update_task",
  "arguments": {
    "sessionId": "my-project",
    "id": 2,
    "status": "check"
  }
}
```

#### ステータス: `error`

以下の場合は `error` に設定：
- ステップの実行中にエラーが発生した
- ビルドやテストが失敗した
- 依存関係のインストールが失敗した

**MCPツール呼び出し:**
```json
{
  "name": "update_task",
  "arguments": {
    "sessionId": "my-project",
    "id": 3,
    "status": "error"
  }
}
```

### 4. 完了タスクのクリア

すべてのタスクが完了したら、ユーザーに確認してから `done` ステータスのタスクをクリアします。

**手順:**

1. **全タスク完了の検出**

   すべてのタスクが `done` または `check` ステータスになったことを確認します。`pending`, `in_progress`, `error` のタスクが残っている場合は、クリア処理を行いません。

2. **ユーザーへの確認**

   AskUserQuestionツールを使用して、ユーザーに確認を求めます：

   ```json
   {
     "name": "AskUserQuestion",
     "arguments": {
       "questions": [
         {
           "question": "すべてのタスクが完了しました。完了済みタスク（doneステータス）をクリアしますか？",
           "header": "タスククリア",
           "options": [
             {
               "label": "クリアする",
               "description": "doneステータスのタスクを削除します"
             },
             {
               "label": "保持する",
               "description": "タスクをそのまま残します"
             }
           ],
           "multiSelect": false
         }
       ]
     }
   }
   ```

3. **ユーザーの回答に応じた処理**

   **ユーザーが「クリアする」を選択した場合:**

   `clear_tasks` MCPツールを呼び出します：
   ```json
   {
     "name": "clear_tasks",
     "arguments": {
       "sessionId": "my-project",
       "clearAll": false
     }
   }
   ```

   **ユーザーが「保持する」を選択した場合:**

   タスクをクリアせず、そのまま保持します。ユーザーに簡潔に通知：
   ```
   タスクを保持しました。
   ```

4. **クリアのオプション**

   `clearAll: false` の場合、`done` ステータスのタスクのみが削除されます。すべてのタスクをクリアする必要がある場合は、別途確認してから `clearAll: true` を設定します。

## 重要な注意事項

### 1. タスクIDの管理

`add_tasks` の結果として返されるタスクIDを記録し、後で `update_task` を呼び出す際に使用します。

タスクIDは各セッション内で独立して管理されます（セッションAのID 1とセッションBのID 1は別物）。

### 2. エラーハンドリング

MCPツールの呼び出しが失敗した場合でも、実装作業は継続します。タスク管理はあくまで補助的な機能であり、メインの作業をブロックしてはいけません。

### 3. ユーザーへの通知

タスクを作成・更新した際は、簡潔にユーザーに通知します：

**良い例:**
```
タスクを作成しました（セッション: my-project、5件）
```

**悪い例:**
```
タスク管理システムにアクセスし、add_tasksツールを使用して、
以下の5つのタスクをmy-projectセッションに追加しました...
```

### 4. セッション名の確認

セッション名を取得したら、最初のタスク作成時にユーザーに確認してもらうことを推奨します：

```
実行計画のタスクをセッション「my-project」に追加します。
```

### 5. タスククリアの確認

タスクをクリアする際は、**必ずユーザーに確認を求めてください**。自動的にタスクを削除してはいけません。

確認のタイミング:
- すべてのタスクが `done` または `check` になった時
- ユーザーが明示的にタスクのクリアを依頼した時

確認せずにクリアしてはいけない理由:
- ユーザーが後で参照したい場合がある
- 作業記録として残したい場合がある
- TUIで完了状態を確認したい場合がある

## 使用例

### 例1: 新機能の実装

**ユーザーのリクエスト:**
```
新しいユーザー認証機能を実装してください
```

**Claude Codeの動作:**

1. EnterPlanMode を使用して実行計画を作成
2. 計画の各ステップを抽出
3. セッション名を取得: `basename $(pwd)` → "my-app"
4. タスクを作成:
   ```json
   {
     "name": "add_tasks",
     "arguments": {
       "sessionId": "my-app",
       "titles": [
         "認証スキーマの作成",
         "ログインAPIの実装",
         "トークン検証の追加",
         "テストの作成"
       ]
     }
   }
   ```
5. ExitPlanMode で計画を確定
6. 各ステップを実装する際:
   - ステップ開始時: `update_task` で `in_progress` に設定
   - ステップ完了時: `update_task` で `done` または `check` に設定
7. すべてのタスクが完了したら:
   - ユーザーに確認: 「完了済みタスクをクリアしますか？」
   - ユーザーが承認した場合のみ `clear_tasks` を実行

### 例2: エラー発生時の処理

**状況:**
```
ビルド中にTypeScriptのエラーが発生
```

**Claude Codeの動作:**

1. 該当タスクを `error` に更新:
   ```json
   {
     "name": "update_task",
     "arguments": {
       "sessionId": "my-app",
       "id": 2,
       "status": "error"
     }
   }
   ```
2. エラーを修正
3. 再度ビルドして成功したら `check` に更新（ビルド結果の確認が必要）

### 例3: 全タスク完了後のクリア

**状況:**
```
すべてのタスクが done または check ステータスになった
```

**Claude Codeの動作:**

1. 全タスク完了を検出

2. ユーザーに確認を求める（AskUserQuestion）:
   ```
   すべてのタスクが完了しました。完了済みタスク（doneステータス）をクリアしますか？

   [ クリアする ]  [ 保持する ]
   ```

3. ユーザーが「クリアする」を選択した場合:
   ```json
   {
     "name": "clear_tasks",
     "arguments": {
       "sessionId": "my-app",
       "clearAll": false
     }
   }
   ```
   通知: 「完了済みタスクをクリアしました。」

4. ユーザーが「保持する」を選択した場合:
   通知: 「タスクを保持しました。」

## テスト

スキルが正しく動作するか確認するには：

1. TUIアプリを起動:
   ```bash
   SESSION=$(basename $(pwd)) npm start
   ```

2. Claude Codeに実行計画を依頼:
   ```
   簡単な機能を3ステップで実装してください
   ```

3. TUIでタスクが作成され、各ステップの完了時にステータスが更新されることを確認

## まとめ

このスキルを使用することで：

- ✅ 実行計画が視覚的なタスクリストとして表示される
- ✅ 進捗状況がリアルタイムで確認できる
- ✅ ユーザーの承認が必要なステップが明確になる
- ✅ 複数のプロジェクトを並行して管理できる（セッション分離）

タスク管理を意識せず、Claude Codeが自動的に進捗を記録してくれます。
